<!DOCTYPE html>






  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.2.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.2.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.2.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.2.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.2.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Hexo</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>




<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/k8s-k8s里的pause镜像/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/k8s-k8s里的pause镜像/" itemprop="url">
                  k8s里的pause镜像
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-07 20:20:30 / Modified: 20:23:41" itemprop="dateCreated datePublished" datetime="2018-05-07T20:20:30+08:00">2018-05-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在kubernetes的Pod启动时，会有一个叫做pause的容器先启动，然后才会轮到有真正服务的pod容器启动。这个pod的作用是什么呢？</p>
<p>pause容器的Dockerfile的内容很少</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ARG ARCH</span><br><span class="line">ADD bin/pause-$&#123;ARCH&#125; /pause</span><br><span class="line">ENTRYPOINT [&quot;/pause&quot;]</span><br></pre></td></tr></table></figure>
<p>可以看到，这里就启动了一个pause程序，再来看下pause程序</p>
<p><a href="https://github.com/kubernetes/kubernetes/blob/master/build/pause/pause.c" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/blob/master/build/pause/pause.c</a></p>
<p>只看main函数里的几行代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if (sigaction(SIGINT, &amp;(struct sigaction)&#123;.sa_handler = sigdown&#125;, NULL) &lt; 0)</span><br><span class="line">    return 1;</span><br><span class="line">if (sigaction(SIGTERM, &amp;(struct sigaction)&#123;.sa_handler = sigdown&#125;, NULL) &lt; 0)</span><br><span class="line">    return 2;</span><br><span class="line">if (sigaction(SIGCHLD, &amp;(struct sigaction)&#123;.sa_handler = sigreap,</span><br><span class="line">                                           .sa_flags = SA_NOCLDSTOP&#125;, NULL) &lt; 0)</span><br><span class="line">    return 3;</span><br><span class="line"></span><br><span class="line">for (;;)</span><br><span class="line">    pause();</span><br></pre></td></tr></table></figure>
<p>sigaction函数指定本程序在接收到SIGINT, SIGTERM, SIGCHLD信号之后做什么处理。<br>设置完后就会通过pause()暂停本进程，一直等待信号，而信号到来后仍然继续循环等待，所以该进程只能通过接收信号后，从信号处理函数里退出了。</p>
<p>信号处理函数就sigdown和sigreap两个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void sigdown(int signo) &#123;</span><br><span class="line">  psignal(signo, &quot;Shutting down, got signal&quot;);</span><br><span class="line">  exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void sigreap(int signo) &#123;</span><br><span class="line">  while (waitpid(-1, NULL, WNOHANG) &gt; 0)</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上面的代码可以看到，进程终止的信号SIGINT, SIGTERM，就是调用psignal输出了信号信息，然后就退出了。集合main函数里的逻辑，pause进程只能从这两个信号退出。</p>
<p>SIGCHLD信号的处理比较特殊。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (waitpid(-1, NULL, WNOHANG) &gt; 0)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
<p>这段代码，一般用父进程有多个子进程时使用，让父进程等待子进程结束。这样做可以防止产生僵尸进程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程可以使用fork和exec syscalls启动其他进程。当启动了其他进程，新进程的父进程就是调用fork syscall的进程。fork用于启动正在运行的进程的另一个副本，而exec则用于启动不同的进程。每个进程在OS进程表中都有一个条目。这将记录有关进程的状态和退出代码。当子进程运行完成，它的进程表条目仍然将保留直到父进程使用wait syscall检索其退出代码将其退出。这被称为“收割”僵尸进程。</span><br><span class="line">僵尸进程是已停止运行但进程表条目仍然存在的进程，因为父进程尚未通过wait syscall进行检索。从技术层面来说，终止的每个进程都算是一个僵尸进程，尽管只是在很短的时间内发生的，但只要不终止他们就可以存活更久。</span><br></pre></td></tr></table></figure>
<p>总结下，pause进程启动后，也就干了两件事</p>
<ul>
<li>重复循环等待信号，只有SIGTERM和SIGINT时才会退出进程</li>
<li>负责回收僵尸子进程</li>
</ul>
<p>在Kubernetes中，pause容器的功能会有所扩展</p>
<ul>
<li>pause容器在创建pod时第一个启动，创建的命名空间作为基础和pod中的其他容器共享</li>
<li>pause容器在PID namespace中是PID为1的init进程，也是Pod中其他容器的父进程，负责回收pod内的僵尸子进程</li>
</ul>
<p>如果不使用pause容器呢，一个是命名空间并不好统一管理，一个是容器将会只能自己收集僵尸进程本身，这对内存会是一个隐患。</p>
<p><img src="images/80C0C662-1BB9-4FD3-A943-91ABE65E5B0B.png" alt=""></p>
<p>参考文章：<br><a href="https://kubernetes.io/docs/concepts/workloads/pods/pod/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/workloads/pods/pod/</a><br><a href="http://dockone.io/article/2785" target="_blank" rel="noopener">http://dockone.io/article/2785</a><br><a href="http://dockone.io/article/2682" target="_blank" rel="noopener">http://dockone.io/article/2682</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/goim解析-数据结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/goim解析-数据结构/" itemprop="url">
                  goim解析-数据结构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-07 10:28:05 / Modified: 10:34:19" itemprop="dateCreated datePublished" datetime="2018-05-07T10:28:05+08:00">2018-05-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>goim中的数据结构主要存在于需要保存状态的节点，除了logic是无状态外，其他的节点comet、router、job都会有数据结构来保持信息。</p>
<h3 id="comet"><a href="#comet" class="headerlink" title="comet"></a>comet</h3><p>comet服务和客户端保持长连接，存在最多最复杂的数据结构</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultServer是全局变量，每启动一个comet服务就会有一个Server对象</span></span><br><span class="line"><span class="comment">// Server主要保存了多个bucket和</span></span><br><span class="line"><span class="keyword">var</span> DefaultServer    *Server</span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">    Buckets   []*Bucket <span class="comment">// 一个server会有多个bucket</span></span><br><span class="line">    bucketIdx <span class="keyword">uint32</span> <span class="comment">// 其实是保存server对象中bucket的数量，方便进行hash计算索引</span></span><br><span class="line">    round     *Round <span class="comment">// 一个server会有一个round</span></span><br><span class="line">    operator  Operator</span><br><span class="line">    Options   ServerOptions <span class="comment">// options保存一些数组初始化时的数量，暂时忽略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- Round ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// round用来保存tcp相关的读写缓冲池，定时器对象等</span></span><br><span class="line"><span class="comment">// readers,writers,timers数组的个数是在服务器启动时指定的，之后无法更改。</span></span><br><span class="line"><span class="comment">// 每次获取时会计算索引，轮询获取Pool或Timer对象，而Pool或Timer里会维护空闲链表</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">type</span> Round <span class="keyword">struct</span> &#123;</span><br><span class="line">    readers   []bytes.Pool <span class="comment">// 读写缓冲区都使用Pool结构体，初始化时创建固定数量的Pool</span></span><br><span class="line">    writers   []bytes.Pool</span><br><span class="line">    timers    []time.Timer <span class="comment">// 定时器使用Timer作为结构体，初始化时创建固定数量的Timer</span></span><br><span class="line">    options   RoundOptions</span><br><span class="line">    readerIdx <span class="keyword">int</span> <span class="comment">// 下面3个都是代表数组的长度，也是轮询方式计算索引获取读写缓冲池或定时器对象</span></span><br><span class="line">    writerIdx <span class="keyword">int</span></span><br><span class="line">    timerIdx  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tcp内存缓冲池，tcp读写操作都会用到这个自定义缓冲区</span></span><br><span class="line"><span class="comment">// 具体tcp连接分配到哪个Pool，是每次递增索引，轮询方式获取</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock sync.Mutex</span><br><span class="line">    free *Buffer <span class="comment">// 这里放的都是空闲的Buffer，tcp连接使用时会从free链表取出Buffer，绑定成该tcp连接的用户态缓冲。tcp连接关闭，则会把Buffer放回到free链表。如果free链表没有可使用的缓冲区，就会grow，创建num个新的Buffer。</span></span><br><span class="line">    max  <span class="keyword">int</span> <span class="comment">// 每次Pool grow时，会先申请max大小字节数组，然后分配给这个num个Buffer</span></span><br><span class="line">    num  <span class="keyword">int</span> <span class="comment">// 每次Pool grow时，创建num个Buffer</span></span><br><span class="line">    size <span class="keyword">int</span> <span class="comment">// 每个Buffer的大小(字节个数)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器对象，TimerData是具体定时器信息，signal是系统定时器</span></span><br><span class="line"><span class="comment">// 看实现是一个时间轮，心跳时间是 infiniteDuration = itime.Duration(1&lt;&lt;63 - 1)</span></span><br><span class="line"><span class="keyword">type</span> Timer <span class="keyword">struct</span> &#123;</span><br><span class="line">    lock   sync.Mutex</span><br><span class="line">    free   *TimerData <span class="comment">// 空闲的TimerData对象链表，操作和Pool的free链表类似</span></span><br><span class="line">    timers []*TimerData <span class="comment">// 在时间轮中等待的TimerData，每次心跳都会检查，然后调用回调</span></span><br><span class="line">    signal *itime.Timer <span class="comment">// 系统Timer对象，会对signal设置固定的定时时间，每次超时就会操作一次timers数组</span></span><br><span class="line">    num    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时数据</span></span><br><span class="line"><span class="keyword">type</span> TimerData <span class="keyword">struct</span> &#123;</span><br><span class="line">    Key    <span class="keyword">string</span></span><br><span class="line">    expire itime.Time <span class="comment">// 超时时间</span></span><br><span class="line">    fn     <span class="function"><span class="keyword">func</span><span class="params">()</span> // 超时回调函数</span></span><br><span class="line"><span class="function">    <span class="title">index</span>  <span class="title">int</span></span></span><br><span class="line"><span class="function">    <span class="title">next</span>   *<span class="title">TimerData</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// --- <span class="title">Bucket</span> ---</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 一个<span class="title">Bucket</span>对象保存多个<span class="title">Channel</span>，每个<span class="title">tcp</span>连接对应一个<span class="title">Channel</span>，然后根据<span class="title">hash</span>计算分配到某个<span class="title">bucket</span>上，然后这个<span class="title">tcp</span>连接的<span class="title">Channel</span>和<span class="title">bucket</span>绑定。</span></span><br><span class="line"><span class="function">// 这里涉及到<span class="title">sub</span> <span class="title">key</span>概念，一个<span class="title">tcp</span>连接对应一个<span class="title">sub</span> <span class="title">key</span>，一个用户可以有多个<span class="title">sub</span> <span class="title">key</span></span></span><br><span class="line"><span class="function"><span class="title">type</span> <span class="title">Bucket</span> <span class="title">struct</span></span> &#123;</span><br><span class="line">    cLock    sync.RWMutex        <span class="comment">// protect the channels for chs</span></span><br><span class="line">    chs      <span class="keyword">map</span>[<span class="keyword">string</span>]*Channel <span class="comment">// map sub key to a channel</span></span><br><span class="line">    boptions BucketOptions</span><br><span class="line">    rooms       <span class="keyword">map</span>[<span class="keyword">int32</span>]*Room <span class="comment">// map roomid to room</span></span><br><span class="line">    routines    []<span class="keyword">chan</span> *proto.BoardcastRoomArg <span class="comment">// room广播，包含多个chan的数组，在服务启动时就会开启同等数量的goroutine，监听chan，每次有广播请求时，会轮询计算出一个goroutine对应的chan，触发信号。</span></span><br><span class="line">    routinesNum <span class="keyword">uint64</span> <span class="comment">// 用来轮询计算索引</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 房间，一个房间可以有多个Channel</span></span><br><span class="line"><span class="keyword">type</span> Room <span class="keyword">struct</span> &#123;</span><br><span class="line">    id     <span class="keyword">int32</span></span><br><span class="line">    rLock  sync.RWMutex</span><br><span class="line">    next   *Channel <span class="comment">// 通过链表形式保存Channel地址</span></span><br><span class="line">    drop   <span class="keyword">bool</span> <span class="comment">// 表示该room是否所有Channel都退出了</span></span><br><span class="line">    Online <span class="keyword">int</span> <span class="comment">// dirty read is ok</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Channel对应一个TCP连接，关联着读写缓冲区，以及一个tcp连接的数据队列Ring</span></span><br><span class="line"><span class="comment">// 用户态缓冲区主要用来处理封包粘包问题</span></span><br><span class="line"><span class="comment">// Channel used by message pusher send msg to write goroutine.</span></span><br><span class="line"><span class="keyword">type</span> Channel <span class="keyword">struct</span> &#123;</span><br><span class="line">    RoomId   <span class="keyword">int32</span></span><br><span class="line">    CliProto Ring <span class="comment">// 和Ring名称一样，是一个环形数据结构，保存着一组客户端tcp发送来的数据。</span></span><br><span class="line">    signal   <span class="keyword">chan</span> *proto.Proto <span class="comment">// 通过signal这个chan来向tcp连接写数据</span></span><br><span class="line">    Writer   bufio.Writer <span class="comment">// 缓冲区，当TCP连接到来，Channel创建时，从Round中获取用户态缓冲区</span></span><br><span class="line">    Reader   bufio.Reader <span class="comment">// 缓冲区，同上</span></span><br><span class="line">    Next     *Channel <span class="comment">// 双向链表</span></span><br><span class="line">    Prev     *Channel</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环形数据结构，保存着一组proto.Proto，也就是按照二进制协议解析完成后的对象，这个数组的数量是固定的。</span></span><br><span class="line"><span class="comment">// Ring.data的数组元素个数固定，如果某次写入不进去，就会阻塞，不会增加Ring.data的大小</span></span><br><span class="line"><span class="keyword">type</span> Ring <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// read</span></span><br><span class="line">    rp   <span class="keyword">uint64</span></span><br><span class="line">    num  <span class="keyword">uint64</span></span><br><span class="line">    mask <span class="keyword">uint64</span></span><br><span class="line">    <span class="comment">// TODO split cacheline, many cpu cache line size is 64</span></span><br><span class="line">    <span class="comment">// pad [40]byte</span></span><br><span class="line">    <span class="comment">// write</span></span><br><span class="line">    wp   <span class="keyword">uint64</span></span><br><span class="line">    data []proto.Proto</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="router"><a href="#router" class="headerlink" title="router"></a>router</h3><p>router是goim里专门负责保存数据的服务，对其他节点提供了rpc调用，主要被logic和job调用。这个服务也可以被redis等替代，因为基本就是在读写一些内存数据，没有额外逻辑。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// router也有一个bucket结构体，不过和comet的bucket保存的信息不同，这里主要保存用户、tcp连接、房间等对象的关联信息。</span></span><br><span class="line"><span class="keyword">type</span> Bucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    bLock             sync.RWMutex</span><br><span class="line">    server            <span class="keyword">int</span>                       <span class="comment">// session server map init num</span></span><br><span class="line">    session           <span class="keyword">int</span>                       <span class="comment">// bucket session init num</span></span><br><span class="line">    sessions          <span class="keyword">map</span>[<span class="keyword">int64</span>]*Session        <span class="comment">// userid-&gt;sessions，一个用户一个session</span></span><br><span class="line">    roomCounter       <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int32</span>           <span class="comment">// roomid-&gt;count，某个room里的channel总数量</span></span><br><span class="line">    serverCounter     <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int32</span>           <span class="comment">// server-&gt;count，某个server里的channel总数量，这个server指的是某个具体的comet节点的server id</span></span><br><span class="line">    userServerCounter <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">map</span>[<span class="keyword">int64</span>]<span class="keyword">int32</span> <span class="comment">// serverid-&gt;userid-&gt;count，某个server里的某个用户的channel总数</span></span><br><span class="line">    cleaner           *Cleaner                  <span class="comment">// bucket map cleaner</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个用户对应一个session</span></span><br><span class="line"><span class="keyword">type</span> Session <span class="keyword">struct</span> &#123;</span><br><span class="line">    seq     <span class="keyword">int32</span> <span class="comment">// seq代表一个用户的新的连接的序列号，从1开始，不断递增，userid+seq就是subkey</span></span><br><span class="line">    servers <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int32</span>           <span class="comment">// seq:server，保存某个连接在哪个comet节点上这样的关联关系，因为需要知道这个关联关系，才可以发送通知时，找到具体的comet节点，然后进行tcp写操作</span></span><br><span class="line">    rooms   <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int32</span> <span class="comment">// roomid:seq:server with specified room id，一个用户所在的房间信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="job"><a href="#job" class="headerlink" title="job"></a>job</h3><p>job服务主要工作就是连接上kafka，接收kafka的消息，然后job调用comet的rpc服务，comet则把请求消息写入到tcp连接，客户端则会接收到通知消息。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// job服务主要工作就是从router上同步channel和commet节点的关联关系，然后当从kafka收到发送通知的请求时，就要调用指定comet节点的rpc服务，进行对应tcp写操作。</span></span><br><span class="line"><span class="comment">// 下面的多个routines都是数组，数组个数相同，job服务启动时会启动这个个数的goroutine，用来接收到kafka消息时，通过chan触发job调用comet的rpc服务的操作</span></span><br><span class="line"><span class="keyword">type</span> Comet <span class="keyword">struct</span> &#123;</span><br><span class="line">    serverId             <span class="keyword">int32</span></span><br><span class="line">    rpcClient            *xrpc.Clients</span><br><span class="line">    pushRoutines         []<span class="keyword">chan</span> *proto.MPushMsgArg <span class="comment">// 数组，每个元素又是一个chan链表</span></span><br><span class="line">    broadcastRoutines    []<span class="keyword">chan</span> *proto.BoardcastArg <span class="comment">// 同上</span></span><br><span class="line">    roomRoutines         []<span class="keyword">chan</span> *proto.BoardcastRoomArg <span class="comment">// 同上</span></span><br><span class="line">    pushRoutinesNum      <span class="keyword">int64</span></span><br><span class="line">    roomRoutinesNum      <span class="keyword">int64</span></span><br><span class="line">    broadcastRoutinesNum <span class="keyword">int64</span></span><br><span class="line">    options              CometOptions</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个结构体用来定时从router获取信息，更新当前goim系统里的客户端连接服务端的状态</span></span><br><span class="line"><span class="keyword">type</span> RoomBucket <span class="keyword">struct</span> &#123;</span><br><span class="line">    roomNum <span class="keyword">int</span></span><br><span class="line">    rooms   <span class="keyword">map</span>[<span class="keyword">int32</span>]*Room</span><br><span class="line">    rwLock  sync.RWMutex</span><br><span class="line">    options RoomOptions</span><br><span class="line">    round   *Round</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定时器，不再赘述</span></span><br><span class="line"><span class="comment">// Ronnd userd for connection round-robin get a timer for split big lock.</span></span><br><span class="line"><span class="keyword">type</span> Round <span class="keyword">struct</span> &#123;</span><br><span class="line">    timers   []time.Timer</span><br><span class="line">    options  RoundOptions</span><br><span class="line">    timerIdx <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/07/goim解析-架构图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/07/goim解析-架构图/" itemprop="url">
                  goim解析-架构图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-05-07 10:22:07 / Modified: 10:34:24" itemprop="dateCreated datePublished" datetime="2018-05-07T10:22:07+08:00">2018-05-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>goim是用来搭建im系统的一套开源服务，主要包含comet、logic、router和job四个服务，然后也需要和消息队列服务kafka一起使用。</p>
<p>下图是四个程序启动时开启的不同协议的服务</p>
<ul>
<li>comet是直接和客户端保持长连接的有状态服务，启动tcp和websocket服务。rpc是提供给job服务调用的。</li>
<li>logic是无状态服务，这里放置主要的业务逻辑。rpc服务供给comet调用。http是提供给其他系统模块调用，有其他业务需要给im连接用户发消息通知时，就可以调用logic的http来发送。</li>
<li>router是用来保存状态的，主要是在部署多个comet节点时，客户端最终和哪个节点建立了长连接，这样的关联关系。rpc服务提供给logic和job调用。作为一个纯内存存取操作的服务，也可以替换成redis之类的应用。</li>
<li>job是用来负责具体推送消息的服务。当logic的rpc被调用后，会执行一些业务逻辑，如果需要发送通知，就会把消息发送给kafka。job监听kafka，接收到kafka的消息后，job就会调用comet的rpc服务，把消息写到对应客户端的tcp连接里。</li>
</ul>
<p><img src="images/goim-architecture.png" alt=""></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/17/如何使用swagger整合api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/17/如何使用swagger整合api/" itemprop="url">
                  如何使用swagger整合api
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-17 02:36:59 / Modified: 10:37:19" itemprop="dateCreated datePublished" datetime="2018-01-17T02:36:59+08:00">2018-01-17</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="swagger-ui的使用"><a href="#swagger-ui的使用" class="headerlink" title="swagger-ui的使用"></a>swagger-ui的使用</h2><ul>
<li>首先有个swagger-ui这个项目，可以根据<code>swagger.json</code>文件的内容，以一种非常漂亮的页面风格显示api信息。</li>
<li>可以直接下载swagger-ui的项目代码，在<code>dist</code>目录下有已经用npm编译好的html页面，直接打开<code>index.html</code>就可以看到。</li>
<li>在地址栏里会是一个默认的值<code>http://petstore.swagger.io/v2/swagger.json</code>，这个值是获取的一个server下的某个路径下的<code>swagger.json</code>文件，所以如果你想自己编写一个<code>swagger.json</code>文件，也必须放在一个服务下跑，才可以正常显示api。</li>
</ul>
<h2 id="如何编写swagger-json"><a href="#如何编写swagger-json" class="headerlink" title="如何编写swagger.json"></a>如何编写swagger.json</h2><ul>
<li><code>swagger.json</code>有自己的格式，我们写代码时不可能写一个api就修改下<code>swagger.json</code>文件，所以需要一种自动生成<code>swagger.json</code>的工具。</li>
<li>一般是借鉴其他语言里的形式，在函数上以特殊规则编写注释，这样就可以使用工具统一生成<code>swagger.json</code>文件</li>
<li>最早注释的形式是在beego里自动集成的，后来<code>https://github.com/yvasiyarov/swagger</code>借鉴beego编写了一个工具，根据注释可以生成各种格式的文档，再后来vmware赞助了一个项目<code>https://github.com/go-swagger/go-swagger</code>，就是借鉴了yvasiyarov的思路，功能更加完善。</li>
</ul>
<h2 id="如何使用go-swagger"><a href="#如何使用go-swagger" class="headerlink" title="如何使用go-swagger"></a>如何使用go-swagger</h2><p>假设已经有一些编写好的go代码文件，直接在目录下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swagger generate spec -o ./swagger.json</span><br></pre></td></tr></table></figure></p>
<p>有了<code>swagger.json</code>文件之后，可以放到项目里保存。如果想查看api信息，可以执行以下命令启动服务。</p>
<blockquote>
<p>参照openshift项目，只保存json文件就可以。如果想在web服务的指定端口直接可以访问API文档，那另说</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swagger serve swagger.json</span><br></pre></td></tr></table></figure>
<p>默认自动启动一个<code>OpenAPI</code>风格的API文档<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:61593/docs</span><br></pre></td></tr></table></figure></p>
<p>而此时<code>swagger.json</code>文件的服务器地址是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:61593/swagger.json</span><br></pre></td></tr></table></figure></p>
<p>需要把这个地址放到<code>swagger-ui</code>里，就可以显示<code>swagger-ui</code>风格的API文档</p>
<h2 id="如何编写api注释"><a href="#如何编写api注释" class="headerlink" title="如何编写api注释"></a>如何编写api注释</h2><p>下面是一个例子，详细的可以参考goswagger的文档<code>https://goswagger.io</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// swagger:operation GET /v1/auth/domain/get domainController getDomainInfo</span><br><span class="line">//</span><br><span class="line">// If the request is successful, will return domain information that the user be able to access.</span><br><span class="line">//</span><br><span class="line">// The system will check user permissions.</span><br><span class="line">// So,you must first login system,and then you can send the request.</span><br><span class="line">//</span><br><span class="line">// You must pass in two arguments, first is offset ,second is limit.</span><br><span class="line">//</span><br><span class="line">// ---</span><br><span class="line">// produces:</span><br><span class="line">// - application/json</span><br><span class="line">// - application/xml</span><br><span class="line">// - text/xml</span><br><span class="line">// - text/html</span><br><span class="line">// parameters:</span><br><span class="line">// - name: offset</span><br><span class="line">//   in: query</span><br><span class="line">//   description: start row number</span><br><span class="line">//   required: true</span><br><span class="line">//   type: integer</span><br><span class="line">//   format: int32</span><br><span class="line">// - name: limit</span><br><span class="line">//   in: query</span><br><span class="line">//   description: maximum number of results to return</span><br><span class="line">//   required: true</span><br><span class="line">//   type: integer</span><br><span class="line">//   format: int32</span><br><span class="line">// responses:</span><br><span class="line">//   &apos;200&apos;:</span><br><span class="line">//     description: success</span><br><span class="line">//   &apos;403&apos;:</span><br><span class="line">//     description: Insufficient permissions</span><br><span class="line">//   &apos;421&apos;:</span><br><span class="line">//     description: get domain information failed.</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/07/k8s-create/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/k8s-create/" itemprop="url">
                  kubernetes pod create流程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-07 15:52:58" itemprop="dateCreated datePublished" datetime="2018-01-07T15:52:58+08:00">2018-01-07</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-05-07 20:20:30" itemprop="dateModified" datetime="2018-05-07T20:20:30+08:00">2018-05-07</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1、用户执行kubectl命令创建pod，根据kubeconfig的配置像kube-apiserver发送创建请求。<br>2、kube-apiserver存储pod数据到etcd，然后返回。剩下的操作异步执行。<br>3、kube-scheduler通过kube-apiserver查看未绑定的pod，尝试为pod分配主机。<br>4、kube-scheduler的调度分为两步：过滤掉不符合要求的主机，为符合要求的主机计算权重。权重的计算设计到一些整体优化策略，比如replicas分配到不同主机，使用负载较低的主机等。<br>5、kube-scheduler选择权重最高的主机，进行binding操作，结果存储到etcd中。kube-scheduler会调用kube-apiserver在etcd创建boundpod对象，描述在一个工作节点上绑定运行的所有pod信息。<br>6、kubelet服务定时和etcd同步boundpod信息，发现一个新的boundpod对象没有在本节点工作，则调用Docker来创建pod。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/07/swift的相关问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/swift的相关问题/" itemprop="url">
                  Swift的相关问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-07 07:59:42 / Modified: 16:06:56" itemprop="dateCreated datePublished" datetime="2018-01-07T07:59:42+08:00">2018-01-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>swift配置时，一般会在系统里单独挂载一个目录，然后当修改配置后，有时候会在系统启动时挂载磁盘时出现错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Continue to wait; or Press S to skip mounting or M for manual recovery</span><br></pre></td></tr></table></figure></p>
<p>在配置swift时都会配置<code>/etc/fstab</code>这个文件，会让系统启动时自动挂载设备。<br>想要跳过这个错误，也可以在该配置文件中加参数<code>nobootwait</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=1234-5678 /osshare vfat utf8,auto,rw,user,nobootwait 0 0</span><br></pre></td></tr></table></figure>
<p>具体的可以<code>man fstab</code>来查看相关信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The  mountall(8) program that mounts filesystem during boot also recognises additional options that the ordinary  mount(8) tool does not. These are:  bootwait which can be applied to remote filesystems mounted outside of /usr or /var, without which mountall(8) would not hold up the boot for these; nobootwait which can be applied to non-remote filesystems to explicitly instruct mountall(8) not to hold up the boot for them;</span><br></pre></td></tr></table></figure>
<hr>
<p>在用devstack安装开发环境后，如果重启，swift服务经常就不能用了。</p>
<p>根据信息查看了目录mount情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">stack@magnum:/opt/stack/solum$ df -h</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev            987M  4.0K  987M   1% /dev</span><br><span class="line">tmpfs           200M  544K  200M   1% /run</span><br><span class="line">/dev/dm-0        91G  6.5G   80G   8% /</span><br><span class="line">none            4.0K     0  4.0K   0% /sys/fs/cgroup</span><br><span class="line">none            5.0M     0  5.0M   0% /run/lock</span><br><span class="line">none           1000M  944K  999M   1% /run/shm</span><br><span class="line">none            100M     0  100M   0% /run/user</span><br><span class="line">/dev/sda1       236M   41M  183M  19% /boot</span><br></pre></td></tr></table></figure></p>
<p>少了一个和swift相关的挂载<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/loop0      6.0G  873M  5.2G  15% /opt/stack/data/swift/drives/sdb1</span><br></pre></td></tr></table></figure></p>
<p>找到默认情况下，swift创建的swift.img，然后手动挂载上去<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t xfs -o loop,noatime,nodiratime,nobarrier,logbufs=8 /opt/stack/data/swift/drives/images/swift.img /opt/stack/data/swift/drives/sdb1/</span><br></pre></td></tr></table></figure></p>
<p>最后还要把这个加到<code>/etc/fstab</code>里，重启时自动挂载，注意这里也加了上面提到的<code>nobootwait</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/stack/data/swift/drives/sdb1/ /opt/stack/data/swift/drives/images/swift.img xfs noatime,nodiratime,nobootwait,nobarrier,logbufs=8 0 0</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/07/ironic和magnum中遇到的错误/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/ironic和magnum中遇到的错误/" itemprop="url">
                  Ironic和magnum中遇到的错误
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-07 07:57:20 / Modified: 17:57:07" itemprop="dateCreated datePublished" datetime="2018-01-07T07:57:20+08:00">2018-01-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>涉及到的component有nova, ironic, glance, neutron, magnum, swift<br>基本错误都是在创建虚拟机的过程中发生的</p>
<p>很多openstack的应用场景都是企业内网，一般会有代理服务器和外部网络隔离</p>
<hr>
<h3 id="用nova-boot在bare-metal上部署"><a href="#用nova-boot在bare-metal上部署" class="headerlink" title="用nova boot在bare metal上部署"></a>用nova boot在bare metal上部署</h3><p>这里和创建虚拟机类似，在nova里都归属为了hypervisor，ironic-conductor会一直和bare metal交互。<br>交互分为两步：先把deploy image安装到机器上，然后用deploy image的操作系统把user image写入到机器的硬盘内。<br>在deploy image启动过程中会出现许多问题。</p>
<p>ironic在mitaka版本以前都只支持flat网络模式，如果创建一个新的节点，会在flat网络中添加一个port。<br>就如neutron port-list中，多出来一个port，而这个port对应于bare metal的四个网口中的一个。</p>
<p>baremetal的inspection操作之后，会自动创建多个port，服务器一般都有四个网口，那么就创建四个port。<br>当nova boot时，会随机选中一个port的mac地址和neutron的网络关联起来，所以就有了ironic node和neutron port的一一对应。<br>但是，实验时有时为了方便，四个网口只插了一跟网线，这在启动过程中就会出问题。</p>
<p>deploy image的挂载没问题，启动过程也不影响，当启动完成后，当bare metal希望和ironic-conductor交互时，网络就连不通了。<br>为何连不通，因为neutron注册的是某个port，只能和这个port交互，但是bare metal这个port没有插网线，数据出不来，然后就悲剧了。</p>
<p>ironic自动创建的port有四个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">stack@Magnum:~/devstack$ ironic port-list</span><br><span class="line">+--------------------------------------+-------------------+</span><br><span class="line">| UUID                                 | Address           |</span><br><span class="line">+--------------------------------------+-------------------+</span><br><span class="line">| bc05cbb9-b6fd-4ebc-b860-81f0033c8828 | ec:b1:d7:83:74:43 |</span><br><span class="line">| 34a4e46c-ff1f-4a24-b351-6a9bb1a5f21b | ec:b1:d7:83:74:42 |</span><br><span class="line">| 3e40c8d2-4f7b-430d-85e3-a884ca48acd0 | ec:b1:d7:83:74:41 |</span><br><span class="line">| 0035a7c8-534c-4d41-a8e0-c0271384408c | ec:b1:d7:83:74:40 |</span><br><span class="line">+--------------------------------------+-------------------+</span><br></pre></td></tr></table></figure></p>
<p>而在ironic conductor服务这边，通过br-ex一直ping不通nova boot的instance分配的ip<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack@Magnum:~/devstack$ ping -I br-ex 172.30.100.104</span><br><span class="line">PING 172.30.100.104 (172.30.100.104) from 172.30.100.10 br-ex: 56(84) bytes of data.</span><br><span class="line">From 172.30.100.10 icmp_seq=1 Destination Host Unreachable</span><br></pre></td></tr></table></figure></p>
<p>查看neutron的port信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack@Magnum:~/devstack$ neutron port-list</span><br><span class="line">+--------------------------------------+------+-------------------+----------------------------------------------------+</span><br><span class="line">| id                                   | name | mac_address       | fixed_ips                                          |</span><br><span class="line">+--------------------------------------+------+-------------------+----------------------------------------------------+</span><br><span class="line">| 3eebcadf-3b22-4208-8960-fed19b2d124b |      | ec:b1:d7:83:74:41 | &#123;&quot;subnet_id&quot;:                                      |</span><br><span class="line">|                                      |      |                   | &quot;59b992ff-1567-4132-a777-70545c075035&quot;,            |</span><br><span class="line">|                                      |      |                   | &quot;ip_address&quot;: &quot;172.30.100.104&quot;&#125;                    |</span><br><span class="line">| a0e1fc5f-15bb-4840-98fb-0577422a62f6 |      | fa:16:3e:0f:14:91 | &#123;&quot;subnet_id&quot;:                                      |</span><br><span class="line">|                                      |      |                   | &quot;59b992ff-1567-4132-a777-70545c075035&quot;,            |</span><br><span class="line">|                                      |      |                   | &quot;ip_address&quot;: &quot;172.30.100.100&quot;&#125;                    |</span><br><span class="line">+--------------------------------------+------+-------------------+----------------------------------------------------+</span><br></pre></td></tr></table></figure></p>
<p>可以看到，neutron port-list中新创建的这个port的mac address和ironic port-list中的某个port对应</p>
<p>neutron网络创建port时，是根据ironic node已有的port进行随机创建的，所以删掉没插网线的port，或者把四个网口全插上网线，这个问题就解决了。</p>
<hr>
<h3 id="ironic-node-inspection时-clean-node-failed"><a href="#ironic-node-inspection时-clean-node-failed" class="headerlink" title="ironic node inspection时 clean node failed"></a>ironic node inspection时 clean node failed</h3><p>在inspection时会自动执行clean node，但是会clean失败（为何失败？）<br>先避开这个功能，在/etc/ironic/ironic.conf中设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">autoclean=False</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="ironic在deoloy过程中，因为某些原因导致deploy失败，会产生脏数据，ironic-node已经绑定instance-uuid，但是instance已经被删除"><a href="#ironic在deoloy过程中，因为某些原因导致deploy失败，会产生脏数据，ironic-node已经绑定instance-uuid，但是instance已经被删除" class="headerlink" title="ironic在deoloy过程中，因为某些原因导致deploy失败，会产生脏数据，ironic node已经绑定instance uuid，但是instance已经被删除"></a>ironic在deoloy过程中，因为某些原因导致deploy失败，会产生脏数据，ironic node已经绑定instance uuid，但是instance已经被删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error contacting Ironic server: Node b362d8ce-1fd3-4cff-afac-c12f01fc02d9 is associated with instance 0d1c7ced-3137-46ce-a3ba-beb7b0c490e1. (HTTP 409). Attempt 2 of 2</span><br></pre></td></tr></table></figure>
<p>这个错误有可能是个隐藏BUG，在ironic的deploy image启动完成后，网络不通连接不上ironic conductor的话，timeout之后，<code>instance就失败被删除????</code>，然后就留下来脏数据。<br>一般通过两种方式清理掉：</p>
<p>正规的就是ironic node-set-maintance <uuid> true，然后ironic node-delete<br>另一种不推荐，就是直接进入数据库改数据，把instance uuid置为NULL</uuid></p>
<hr>
<h3 id="magnum-bay-create时会出现请求不到外网的错误"><a href="#magnum-bay-create时会出现请求不到外网的错误" class="headerlink" title="magnum bay-create时会出现请求不到外网的错误"></a>magnum bay-create时会出现请求不到外网的错误</h3><p>magnum本身是和容器结合的模块，在创建时时会有一个请求discovery url的过程，是外网地址，企业内网中要死不死的没有设置代理的话，就会出错。<br>magnum的github上有说可以在命令行指定代理参数，但是估计是比较新的版本上有的，我在公司机器上试会找不到这个参数。<br>Openstack官方文档：<a href="http://docs.openstack.org/developer/magnum/troubleshooting-guide.html#etcd-service" target="_blank" rel="noopener">http://docs.openstack.org/developer/magnum/troubleshooting-guide.html#etcd-service</a><br>这个对外网的请求是和etcd service有关，etcd是一个高可用的键值存储系统，主要用于共享配置和服务发现，灵感来源于zookeeper.<br>在集群中，用于同步同类节点之间的状态，replication等等的功能都得依靠这个。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/07/bash-shell-tips/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/bash-shell-tips/" itemprop="url">
                  Bash Shell Tips
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-07 07:56:15 / Modified: 17:57:41" itemprop="dateCreated datePublished" datetime="2018-01-07T07:56:15+08:00">2018-01-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对企业级产品里的脚本中常用shell做个记录，平时不写shell很少注意到。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>控制环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set -o errexit -o nounset -o pipefail</span><br></pre></td></tr></table></figure></p>
<h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p>用来修改参数数组<code>$@</code><br>假设执行shell命令<code>bash test.sh 1 2 3 4 5</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">echo $@  # 1 2 3 4 5</span><br><span class="line"></span><br><span class="line">shift</span><br><span class="line"># 等同于shift 1</span><br><span class="line">echo $@  # 2 3 4 5</span><br><span class="line"></span><br><span class="line">shift</span><br><span class="line">echo $@  # 3 4 5</span><br><span class="line"></span><br><span class="line">shift 2</span><br><span class="line">echo $@  # 5</span><br></pre></td></tr></table></figure></p>
<p>可以看到shift可以加参数也可以不加，加参数就是从当前参数数组的第几个参数开始截断</p>
<h2 id="0"><a href="#0" class="headerlink" title="$? $0 $@"></a>$? $0 $@</h2><p>返回值，参数，默认值等等<br>${4:-$COMMAND}</p>
<h2 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h2><p>声明参数<br>尤其是声明全局参数</p>
<h2 id="if"><a href="#if" class="headerlink" title="if"></a>if</h2><p>判断表达式的用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">if [ -d /test_dir/ ]; then</span><br><span class="line">    # 检测目录是否存在</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -f /test_file ]; then</span><br><span class="line">    # 检测文件是否存在</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [ -z $TEST_VAL ]; then</span><br><span class="line">    # 如果变量为空</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p>
<p>比较两个浮点型变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$s1=10</span><br><span class="line">$s2=9</span><br><span class="line"></span><br><span class="line">echo $s1&apos;&gt;&apos;$s2 | bc -l</span><br><span class="line">0</span><br><span class="line">echo $s2&apos;&gt;&apos;$s1 | bc -l</span><br><span class="line">1</span><br><span class="line"></span><br><span class="line">$s1=10</span><br><span class="line">$s2=10</span><br><span class="line"></span><br><span class="line">echo $s1&apos;&gt;&apos;$s2 | bc -l</span><br><span class="line">0</span><br><span class="line">echo $s2&apos;&gt;&apos;$s1 | bc -l</span><br><span class="line">0</span><br></pre></td></tr></table></figure></p>
<h2 id="trap"><a href="#trap" class="headerlink" title="trap"></a>trap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap - INT</span><br></pre></td></tr></table></figure>
<h2 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h2><p><code>tr</code></p>
<h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><p><code>cut</code></p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOM</span><br><span class="line">EOM</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>
<h2 id="local"><a href="#local" class="headerlink" title="local"></a>local</h2><p><code>local</code></p>
<h2 id="echo-e"><a href="#echo-e" class="headerlink" title="echo -e"></a>echo -e</h2><p><code>echo -e</code></p>
<h2 id="case-esac"><a href="#case-esac" class="headerlink" title="case esac"></a>case esac</h2><p><code>case esac</code></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/07/solum简介/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/solum简介/" itemprop="url">
                  Solum简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-07 07:53:23 / Modified: 17:59:44" itemprop="dateCreated datePublished" datetime="2018-01-07T07:53:23+08:00">2018-01-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>solum是部署web application的项目。<br>web app都是跑在各种web server中，所以solum的操作就分为了languagepack和app两个部分。</p>
<p>solum的作用</p>
<ul>
<li>搭建自动测试系统，并且可以设置在多个版本的runtime环境中进行测试。</li>
<li>自动化部署</li>
<li>应用开发的整个生命周期管理</li>
<li>上述这些都可以和github和docker的特性结合起来，快捷方便</li>
<li>CI/CD</li>
</ul>
<p>下面是部署部署一个app的流程的用到的命令总览：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ solum languagepack create &lt;NAME&gt; &lt;GIT_REPO&gt;</span><br><span class="line">$ solum languagepack show &lt;UUID/Name&gt;</span><br><span class="line">$ solum languagepack logs &lt;UUID&gt;</span><br><span class="line">$ solum languagepack list</span><br><span class="line">$ solum app create --app-file &lt;app_file&gt; [--param-file param_file]</span><br><span class="line">$ solum app show &lt;UUID/Name&gt;</span><br><span class="line">$ curl &lt;application_uri&gt;</span><br></pre></td></tr></table></figure>
<h3 id="languagepack"><a href="#languagepack" class="headerlink" title="languagepack"></a>languagepack</h3><p>这个步骤可以创建python、java或其他语言的web应用运行环境。<br>languagepack需要指定一个git repo，下载Dockerfile和build.sh。</p>
<ul>
<li>Dockerfile用来创建docker image。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:14.04</span><br><span class="line"></span><br><span class="line">RUN apt-get -yqq update</span><br><span class="line">RUN apt-get -yqq install python-pip</span><br><span class="line">RUN apt-get -yqq install python-dev</span><br><span class="line"></span><br><span class="line">COPY build.sh /solum/bin/</span><br></pre></td></tr></table></figure>
<ul>
<li>build.sh用来在创建app时执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line"># Check if pip is installed</span><br><span class="line">pip help</span><br><span class="line">[[ $? != 0 ]] &amp;&amp; echo python-pip is not installed. &amp;&amp; exit 1</span><br><span class="line"></span><br><span class="line"># Install dependencies from app requirements file</span><br><span class="line">cd /app</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>
<h3 id="app"><a href="#app" class="headerlink" title="app"></a>app</h3><p>创建app会包含一个workflow流程，根据已有的languagepack创建最终的deployment unit(DU)，然后用heat去部署.</p>
<h4 id="deployment-unit-DU"><a href="#deployment-unit-DU" class="headerlink" title="deployment unit(DU)"></a>deployment unit(DU)</h4><p>DU就是一个打包好的安装了运行环境和application的docker image，可以直接用来创建container运行。<br>当然这个docker image需要languagepack和app两个步骤最终完成创建。</p>
<h4 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h4><ul>
<li>unittest</li>
<li>build</li>
<li>deploy</li>
</ul>
<p>标准的三个步骤，但是这个三个步骤可以选择性的执行，比如只执行unittest和build.</p>
<p>workflow的相关信息都是在appfile.yaml里定义，由参数–app-file指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">version: 1</span><br><span class="line">name: cherrypy</span><br><span class="line">description: python web app</span><br><span class="line">languagepack: python</span><br><span class="line">source:</span><br><span class="line">  repository: https://github.com/rackspace-solum-samples/solum-python-sample-app.git</span><br><span class="line">  revision: master</span><br><span class="line">workflow_config:</span><br><span class="line">  test_cmd: ./unit_tests.sh  # 在unittest步骤里执行什么命令</span><br><span class="line">  run_cmd: python app.py  # 在build步骤执行什么命令</span><br><span class="line">trigger_actions:</span><br><span class="line"> - unittest</span><br><span class="line"> - build</span><br><span class="line"> - deploy  # 就是nova boot的步骤，不过这个依赖nova-docker</span><br><span class="line">ports:</span><br><span class="line"> - 80</span><br></pre></td></tr></table></figure>
<ul>
<li>unittest会根据LP去执行<code>docker build</code>，执行unittest脚本，但是不会保存到glance或swift里</li>
<li>build这个步骤，根据LP执行<code>docker build</code>，执行build.sh脚本，最终保存到glance或swift里</li>
<li>deploy就是通过heat进行nova boot的步骤，依赖nova-docker驱动，从neutron申请IP，从glance下载image。这些取代了直接通过docker的api进行创建容器。<br>这个步骤可以和k8s、mesos以及swarm结合使用。<br>solum的配置文件中有这个参数：<code>docker_daemon_url = unix://var/run/docker.sock</code><br>solum的对docker的操作，都是通过url的remote API进行请求的。那么，对于docker服务，可以是单独的docker服务，也可以是k8s之类的集群，只要提供和docker一致的API。</li>
</ul>
<blockquote>
<p><a href="https://wiki.openstack.org/wiki/Solum/configurations" target="_blank" rel="noopener">https://wiki.openstack.org/wiki/Solum/configurations</a> solum的deploy可以基于docker部署，也可以基于VM</p>
</blockquote>
<ul>
<li>docker<ul>
<li>设置nova-docker驱动 <code>/etc/nova/nova.conf</code>: compute_driver = novadocker.virt.docker.driver.DockerDriver</li>
<li>把solum的存储项设置为glance <code>/etc/solum/solum.conf</code> image_storage = glance</li>
<li>最后部署的时候需要用<code>basic</code>heat template，<a href="https://github.com/openstack/solum/blob/master/etc/solum/templates/basic.yaml" target="_blank" rel="noopener">https://github.com/openstack/solum/blob/master/etc/solum/templates/basic.yaml</a></li>
</ul>
</li>
<li>VM<ul>
<li><code>/etc/nova/nova.conf</code> compute_driver = libvirt.LibvirtDriver</li>
<li><code>/etc/solum/solum.conf</code> image_storage = swift，image_format = vm</li>
</ul>
</li>
</ul>
<p>当用VM在solum里部署应用时，步骤比较绕</p>
<ul>
<li>用disk-image-builder创建带有docker的VM image</li>
<li>用这个image创建docker的container，再通过docker的api去安装app的源码，进行测试等操作，最后把image保存到glance</li>
<li>最终用这个image部署在VM上</li>
</ul>
<h4 id="param-file"><a href="#param-file" class="headerlink" title="param_file"></a>param_file</h4><p>在<code>solum app create</code>时也可以用–param-file指定想要inject的参数<br>这些参数可以通过build步骤里命令脚本去操作</p>
<h3 id="app代码的自动更新部署"><a href="#app代码的自动更新部署" class="headerlink" title="app代码的自动更新部署"></a>app代码的自动更新部署</h3><p>app的代码也在git里，而且可以在自己的git里设置hook，在提交代码后，自动向这个web app的地址发送一个POST请求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.0.2.15:9777/v1/triggers/&lt;trigger_id&gt;</span><br></pre></td></tr></table></figure>
<p>solum会自动重新build一个新的image然后重新部署app</p>
<p>如果是github的源码，在project的设置里可以设定这个trigger url</p>
<h3 id="devstack开发环境"><a href="#devstack开发环境" class="headerlink" title="devstack开发环境"></a>devstack开发环境</h3><p>一共有两种方式，一种用vagrant一种用devstack，直接devstack就可以。</p>
<p>wiki文档地址：<a href="https://wiki.openstack.org/wiki/Solum/solum-development-setup" target="_blank" rel="noopener">https://wiki.openstack.org/wiki/Solum/solum-development-setup</a></p>
<ul>
<li>local.conf文件直接从它提供的外网地址下载</li>
<li>local.conf的配置尤其是密码最好别变，有的服务的密码没有做成可配置，仍然是默认的solum，改动会导致后续的验证失败。</li>
<li>nova和neutron先手动下载源码后再git checkout到指定的change id里，应该是最新代码还没测试完。</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/07/DCOS和mesos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="fengbeihong">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/07/DCOS和mesos/" itemprop="url">
                  DCOS和mesos
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-01-07 07:53:06 / Modified: 18:06:17" itemprop="dateCreated datePublished" datetime="2018-01-07T07:53:06+08:00">2018-01-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Mesos"><a href="#Mesos" class="headerlink" title="Mesos"></a>Mesos</h3><p>mesos本身的目的是针对当前的各种分布式系统的抽象，拿原始的操作系统进行对比，内核控制各个进程执行某些任务，而到了分布式时代，要从更高层面去看，把每个物理节点当做一个进程，有专门的服务作为抽象的内核对进程进行调控，分配给各个进程去执行任务，就像下面的图，特别像操作系统的概念。<br><img src="https://docs.mesosphere.com/1.10/img/dcos-architecture-layers.png" alt="mesos架构"></p>
<h3 id="DC-OS"><a href="#DC-OS" class="headerlink" title="DC/OS"></a>DC/OS</h3><p>Data Center Operating System<br>算是mesos的超集，采用了mesos的kernel，然后把mesos中常用的framework(mesos中的概念，表示进程要执行的任务，具体到节点就是mesos的某些agent节点组成的安装的具体的分布式软件)整合到了dcos中，并且提供了良好的界面和CLI，也继承了许多企业级服务如marathon和chronos等，用dcos来完成mesos的data center功能十分高效便捷。</p>
<p><a href="https://support.mesosphere.com/hc/en-us/articles/205097325-How-is-the-Mesosphere-DCOS-different-from-Apache-Mesos-" target="_blank" rel="noopener">https://support.mesosphere.com/hc/en-us/articles/205097325-How-is-the-Mesosphere-DCOS-different-from-Apache-Mesos-</a></p>
<h3 id="DC-OS是运行容器的最好方式"><a href="#DC-OS是运行容器的最好方式" class="headerlink" title="DC/OS是运行容器的最好方式"></a>DC/OS是运行容器的最好方式</h3><p><a href="https://mesosphere.com/blog/2016/04/19/open-source-dcos/" target="_blank" rel="noopener">https://mesosphere.com/blog/2016/04/19/open-source-dcos/</a></p>
<p>mesos可以安装运行各种分布式软件，当然也包括docker，不过在最新的mesos1.0中，mesos也实现了自己的容器化技术，就算不安装docker也可以跑容器了。当然，这些容器化技术大概在2015年都统一了标准，互相兼容的。</p>
<h3 id="mesos的手动配置"><a href="#mesos的手动配置" class="headerlink" title="mesos的手动配置"></a>mesos的手动配置</h3><p>按照magnum中的部署mesos环境的步骤，手动配置的话模板里会有以下和mesos相关的参数：</p>
<h3 id="magnum部署mesos的流程"><a href="#magnum部署mesos的流程" class="headerlink" title="magnum部署mesos的流程"></a>magnum部署mesos的流程</h3><ul>
<li>首先准备image文件，在image文件会安装好mesos服务所需的zookeeperd、mesos和marathon服务，以及docker-engine服务。</li>
<li>先启动magnum参数所指定的几个master虚拟机，启动完成后会对master节点的服务进行配置，并且启动这些服务。</li>
<li>然后启动agent节点，启动完成后会在节点内部创建<code>/etc/sysconfig/heat-params</code>文件，然后配置agent节点服务，启动服务，最后要等待执行<code>agent_wc_notify</code>操作，并且设置volume服务。</li>
</ul>
<h3 id="magnum中coe的设计思路"><a href="#magnum中coe的设计思路" class="headerlink" title="magnum中coe的设计思路"></a>magnum中coe的设计思路</h3><p>按照magnum里的coe的设计思路，是希望集群里所需要的软件都在image里安装好，之后只需要根据选项进行配置启动就可以。<br>那么如果把mesos换成dcos，dcos中涉及到的几十个应用也需要提前安装好，在部署完dcos后也可以随时安装卸载对应应用<br>这就得舍弃dcos提供的安装流程，相当于舍弃已经整合好的安装脚本，换成手动在magnum里重新实现一遍</p>
<h3 id="dcos的安装流程"><a href="#dcos的安装流程" class="headerlink" title="dcos的安装流程"></a>dcos的安装流程</h3><p>说下advanced安装方式，在每个节点进行执行的操作来手动执行</p>
<ul>
<li>先准备两个文件<code>ip-detect</code>和<code>config.yaml</code>，检测IP和进行集群的配置</li>
<li>下载安装脚本文件，这个shell文件里，其实除了脚本还包含了压缩包二进制文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -O https://downloads.dcos.io/dcos/EarlyAccess/commit/14509fe1e7899f439527fb39867194c7a425c771/dcos_generate_config.sh</span><br></pre></td></tr></table></figure>
<ul>
<li>执行<code>dcos_generate_config.sh</code>脚本文件，默认的参数就是<code>--genconf</code>，生成了安装的配置信息，文件和路径信息就会如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── dcos-genconf.&lt;HASH&gt;.tar</span><br><span class="line">├── dcos_generate_config.sh</span><br><span class="line">├── genconf</span><br><span class="line">│   ├── serve</span><br><span class="line">│   │   ├── dcos_install.sh</span><br><span class="line">│   ├── config.yaml</span><br><span class="line">│   ├── ip-detect</span><br><span class="line">│   ├── cluster_packages.json</span><br><span class="line">│   ├── ssh_key</span><br><span class="line">│   ├── state</span><br></pre></td></tr></table></figure>
<ul>
<li>然后执行<code>docker run</code>，这一步会在bootstrap node启动一个nginx的容器服务，映射端口，并且把<code>./genconf/serve/</code>目录映射到nginx容器里的<code>/usr/share/nginx/html</code>，路径映射的结果就是，可以从其他节点访问nginx服务获取<code>serve</code>目录下的文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d -p &lt;your-port&gt;:80 -v $PWD/genconf/serve:/usr/share/nginx/html:ro nginx</span><br></pre></td></tr></table></figure>
<ul>
<li>剩下的步骤就是登录到各个节点，master和agent节点，下载下来dcos_install.sh，然后执行安装就可以了<br>安装时要指定<code>role</code>，即当前机器为哪类节点，支持<code>master</code>，<code>slave</code>，<code>slave_public</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh &lt;master-ip&gt;</span><br><span class="line">$ mkdir /tmp/dcos &amp;&amp; cd /tmp/dcos</span><br><span class="line">$ curl -O http://&lt;bootstrap-ip&gt;:&lt;your_port&gt;/dcos_install.sh</span><br><span class="line">$ sudo bash dcos_install.sh master</span><br></pre></td></tr></table></figure>
<ul>
<li>最后一步就是等待安装完成并且各个节点之间同步完成，如何检测状态，查看<code>Exhibitor</code>服务的信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;master-ip&gt;:8181/exhibitor/v1/ui/index.html</span><br></pre></td></tr></table></figure>
<ul>
<li>现在可以启动DCOS的web界面</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;master-node-public-ip&gt;/</span><br></pre></td></tr></table></figure>
<h3 id="bootstrap-node"><a href="#bootstrap-node" class="headerlink" title="bootstrap node"></a>bootstrap node</h3><p>bootstrap节点是干啥的，在安装过程中都会先启动bootstrap node，把要安装的东西压下载到bootstrap node，生成配置文件，然后进行安装。<br>安装时也会通过某种方式把配置文件和安装脚本拷贝到master或者agent节点去，然后在具体的节点上执行安装。<br>文档说bootstrap node是集群的永久性节点，但是个人感觉不是必须的，只是集群必须有一个执行安装程序的节点，卸载时也会需要一个节点来跑执行程序，那么就放到了bootstrap node上，然后bootstrap node也提供了界面化的安装和卸载。<br>如果把安装放到magnum里去做，那么执行安装程序的操作就交给了magnum的HOT去做，拷贝文件也可以由magnum去做，卸载就是直接删除集群节点，整个流程就用不到bootstrap node了。<br>另外，在dcos官网的design页面看到，components需要提前下载，并且是在bootstrap node下载，并且build完成，打包，然后再copy到master或agent节点去安装。<br>那么如果修改的话就方便了，因为dcos_install.sh脚本做的工作就是一个下载，解压，修改配置文件和启动服务。之前的操作放置到DIB里去做。</p>
<h3 id="在安装过程中，master节点，agent节点和bootstrap节点都做了什么具体的工作"><a href="#在安装过程中，master节点，agent节点和bootstrap节点都做了什么具体的工作" class="headerlink" title="在安装过程中，master节点，agent节点和bootstrap节点都做了什么具体的工作"></a>在安装过程中，master节点，agent节点和bootstrap节点都做了什么具体的工作</h3><p>参照官网文档：<a href="https://dcos.io/docs/1.8/overview/architecture/" target="_blank" rel="noopener">https://dcos.io/docs/1.8/overview/architecture/</a></p>
<h3 id="DC-OS的安装脚本生成流程，以及安装流程"><a href="#DC-OS的安装脚本生成流程，以及安装流程" class="headerlink" title="DC/OS的安装脚本生成流程，以及安装流程"></a>DC/OS的安装脚本生成流程，以及安装流程</h3><p>dcos的源码下载下来后，根目录执行<code>build_local.sh</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Install the DC/OS tools</span><br><span class="line">./prep_local</span><br><span class="line"></span><br><span class="line"># Build a release of DC/OS</span><br><span class="line">release create `whoami` local_build</span><br></pre></td></tr></table></figure>
<p>第一步pre_local会执行setuptools的打包脚本，打包出一些需要的命令，比如release命令(python命令)<br>第二步就正式执行打包命令</p>
<ul>
<li>下载packages，编译，保存编译结果</li>
<li>把一些模板文件和配置文件初始化</li>
<li>把上述的文件根据Dockerfile，docker build出docker image的tar包</li>
<li>最终把docker image和脚本文件合并成为<code>dcos_generate_config.sh</code></li>
</ul>
<p>dcos_generate_config.sh是最初的安装脚本，由脚本和一个docker image二进制数据共同组成。</p>
<ul>
<li>脚本由dcos_generate_config.sh.in模板生成</li>
<li>docker image由配置的各个文件和Dockerfile，一起<code>docker build</code>后进行<code>docker save</code>的一个tar包。所以不能只看tar包信息，需要看<code>docker build</code>前的原始信息。</li>
</ul>
<p>执行<code>dcos_generate_config.sh --genconf</code>会生成配置文件，这一步会执行<code>docker run</code>，运行的就是docker image里的内容。那么要看如何生成配置文件，就需要看docker image是如何生成的。<br><code>dcos_generate_config.sh --genconf</code>在源码中的entry_point是<code>ext/dcos-installer/cli.py:main</code></p>
<p>综上，要抽出安装脚本中需要的部分：packages文件、配置文件以及安装脚本<br>其中packages文件要放到DIB中，配置文件无需改动的放到DIB中，安装脚本和部分需要改动的配置文件放在外面<br>对应到执行命令，就是<code>dcos_generate_config.sh --genconf</code>这个操作时，会变动的配置文件放到外面，其他的放到DIB中</p>
<ul>
<li>下载dcos源码，从头制作安装文件<br>这种需要重新下载和build各个packages包，还要初始化各个配置文件，耗时长，也有很多不确定因素会导致失败</li>
<li>直接下载编译好的dcos_generate_config.sh<br>这种需要执行<code>docker run</code>才能生成配置文件，依赖docker，但是解压文件后都是编译好的packages，节省时间，但是下载整个文件也需要花一定时间。</li>
</ul>
<p>制作DIB</p>
<ul>
<li>下载<code>dcos_generate_config.sh</code>，执行<code>dcos_generate_config.sh --genconf</code>，生成配置文件</li>
<li>找到安装过程脚本，单独执行，把packages文件和配置文件放置到对应位置，生成DIB</li>
</ul>
<p>magnum中的可配置文件</p>
<ul>
<li>找到生成配置文件的脚本，把ip-detect和cloud-config.yaml所影响的配置文件集中放置在magnum中，初始化这些模板文件后，拷贝到对应位置</li>
<li><code>ext/dcos-installer/cli.py:main</code></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">fengbeihong</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">15</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">fengbeihong</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.2.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.2.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.2.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.2.0"></script>



  



	





  





  










  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  
  

  

  

  

  

  

</body>
</html>
